//-O2;-Wall;-march=cascadelake;-mavx2;-mavx512f;-mavx512cd;-mavx512vl;-mavx512bw;-mavx512dq;-mavx512ifma;-mavx512vbmi


#include <stdio.h>
#include <stdint.h>
#include "Functions.h"
#include "VectorType.h"
#include "Convert.h"
#include "L_tr_bitslice.h"
#include "Kuznechik_bitslice.h"
#include "PiCoordFuncSSE.h"


int main(int argc, char *argv[])
{
	char *fn = NULL;
	if (argc > 1)
	{
		fn = argv[1];
	}

//	const uint8_t PiStroke[] = { 252, 238, 221, 17, 207, 110, 49, 22, 251, 196, 250, 218, 35, 197, 4, 77, 233, 119, 240, 219, 147, 46, 153, 186, 23, 54, 241, 187, 20, 205, 95, 193, 249, 24, 101, 90, 226, 92, 239, 33, 129, 28, 60, 66, 139, 1, 142, 79, 5, 132, 2, 174, 227, 106, 143, 160, 6, 11, 237, 152, 127, 212, 211, 31, 235, 52, 44, 81, 234, 200, 72, 171, 242, 42, 104, 162, 253, 58, 206, 204, 181, 112, 14, 86, 8, 12, 118, 18, 191, 114, 19, 71, 156, 183, 93, 135, 21, 161, 150, 41, 16, 123, 154, 199, 243, 145, 120, 111, 157, 158, 178, 177, 50, 117, 25, 61, 255, 53, 138, 126, 109, 84, 198, 128, 195, 189, 13, 87, 223, 245, 36, 169, 62, 168, 67, 201, 215, 121, 214, 246, 124, 34, 185, 3, 224, 15, 236, 222, 122, 148, 176, 188, 220, 232, 40, 80, 78, 51, 10, 74, 167, 151, 96, 115, 30, 0, 98, 68, 26, 184, 56, 130, 100, 159, 38, 65, 173, 69, 70, 146, 39, 94, 85, 47, 140, 163, 165, 125, 105, 213, 149, 59, 7, 88, 179, 64, 134, 172, 29, 247, 48, 55, 107, 228, 136, 217, 231, 137, 225, 27, 131, 73, 76, 63, 248, 254, 141, 83, 170, 144, 202, 216, 133, 97, 32, 113, 103, 164, 45, 43, 9, 91, 203, 155, 37, 208, 190, 229, 108, 82, 89, 166, 116, 210, 230, 244, 180, 192, 209, 102, 175, 194, 57, 75, 99, 182 };	
//	int i;
//	for (i=0;i<256;++i)
//	{
//		if (i && !(i&0xF)) printf("\n");
//		if (i&0xF) printf(" ");
//		printf("%02X", PiStroke[i]);
//	}
//	printf("\n");
//	return 0;

//	__m512i w512;	
//	w512 = _mm512_set_epi64(
//		0x1111111111111111,
//		0x2222222222222222,
//		0x3333333333333333,
//		0x4444444444444444,
//		0x5555555555555555,
//		0x6666666666666666,
//		0x7777777777777777,
//		0x8888888888888888);

//	_ALIGN(64) const __m512i perm_1 = _mm512_set_epi8(
//		63,55,47,39,31,23,15,7,
//		62,54,46,38,30,22,14,6,
//		61,53,45,37,29,21,13,5,
//		60,52,44,36,28,20,12,4,
//		59,51,43,35,27,19,11,3,
//		58,50,42,34,26,18,10,2,
//		57,49,41,33,25,17,9,1,
//		56,48,40,32,24,16,8,0
//	);
//	_ALIGN(64) const __m512i perm_1 = _mm512_set_epi8(
//		0,1,2,3,4,5,6,7,
//		8,9,10,11,12,13,14,15,
//		16,17,18,19,20,21,22,23,
//		24,25,26,27,28,29,30,31,
//		0,1,2,3,4,5,6,7,
//		8,9,10,11,12,13,14,15,
//		16,17,18,19,20,21,22,23,
//		24,25,26,27,28,29,30,31
//	);
	
	//!!! компилируется с -mavx512vbmi но эту инструкцию не поддерживает Xeon noda9
	//w512 = _mm512_permutexvar_epi8(perm_1, w512);
	
//	_ALIGN(64) const __m512i perm16x32_1 = _mm512_set_epi32(15,13,11,9,7,5,3,1,14,12,10,8,6,4,2,0);
//	_ALIGN(64) const __m512i perm = _mm512_set_epi8(15,14,11,10,7,6,3,2,13,12,9,8,5,4,1,0,15,14,11,10,7,6,3,2,13,12,9,8,5,4,1,0,15,14,11,10,7,6,3,2,13,12,9,8,5,4,1,0,15,14,11,10,7,6,3,2,13,12,9,8,5,4,1,0);
//	_ALIGN(64) const __m512i perm16x32_2 = _mm512_set_epi32(15,14,11,10,13,12,9,8,7,6,3,2,5,4,1,0);
//	_ALIGN(64) const __m512i perm_final = _mm512_set_epi8(15,13,11,9,7,5,3,1,14,12,10,8,6,4,2,0,15,13,11,9,7,5,3,1,14,12,10,8,6,4,2,0,15,13,11,9,7,5,3,1,14,12,10,8,6,4,2,0,15,13,11,9,7,5,3,1,14,12,10,8,6,4,2,0);

//	uint8_t *p=(uint8_t*)&w512;
//	for (int i=0;i<64;++i)
//	{
//		printf("%02X ", p[i]);
//	}
//	printf("\n");
//
//	w512 = _mm512_shuffle_epi8(w512,perm_1);

//	w512 = _mm512_permutexvar_epi32(perm16x32_1, w512); // младшие 4 байта от каждого из восьми блоков в младшую часть вектора w512. Т.е. старшие 256 бит вектора w512 работают со старшими 4 байтами 8 блоков, а младщие 256 бит с младшими 4 байтами 8 блоков
//	w512 = _mm512_shuffle_epi8(w512,perm); // собираю по 2 байта
//	w512 = _mm512_permutexvar_epi32(perm16x32_2, w512); // делаю перестановку среди 32-х битовых переменных, чтобы байты сообщений 1..4 оказались в левом 128-битовом векторе, а байты сообщений 5..8 в правом 128-битовом векторе
//	w512 = _mm512_shuffle_epi8(w512,perm_final); // после этой перестановки - байты 1..8 вектора w256 будут являться первыми байтами сообщений 1..8, байты 9..16 будут являться вторыми байтами сообщений 1..8, байты 17..24 будут являться третьими байтами сообщений 1..8, ...
//	
//	for (int i=0;i<64;++i)
//	{
//		printf("%02X ", p[i]);
//	}
//	printf("\n");
	
	//return 0;
	
//	L_transform_bitslice_test();
//
	printf("PiVersion %u\n", PiVersion());
//
	Kuznechik_bitslice_encrypt_test();

	const uint32_t countTestMessage = 1<<24; //1 << 24; //MaxCountMessage
	//Kuznechik_bitslice_encrypt_test_2(countTestMessage);
	if (fn == NULL)
		Kuznechik_bitslice_encrypt_test_3(countTestMessage);
	else			
		Kuznechik_bitslice_encrypt_file(fn);

	return 0;
}


